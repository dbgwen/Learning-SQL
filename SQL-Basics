SQL was developed by IBM in the 1970s, originally called SEQUEL. It was then changed to SQL due to trademarks. In non-ENglish languages many pronounce it S-Q-L instead of Sequel. Many pronounce it both ways. 

SQL Basics
  Query language for relational databases
  Relational databases makes it easier to relate multiple tables

## Creating a Table + Inserting Data
    CREATE TABLE table_name (column_names); 
    CREATE TABLE grocery (id INTEGER PRIMARY KEY, name TEXT, quantity INTEGER);
        **Typically identify the ID column first
        
    INSERT INTO groceries VALUES( (1, "Bananas", 4); 
    INSERT INTO groceries VALUES (2, "Peanut Butter", 1); 
    INSERT INTO groceries VALUES (3, "Dark Chocolate", 2); 
    
    SELECT column_name FROM table_name; 
    SELECT * FROM groceries ORDER BY column_name; 
    SELECT * FROM groceries WHERE column_name > 5 ORDER BY column_name; 
    
    CREATE TABLE groceries (id INTEGER PRIMARY KEY, name TEXT, quantity INTEGER, aisle INTEGER); 
    INSERT INTO groceries VALUES (1,"Bananas", 56, 7); 
    INSERT INTO groceries VALUES (2, "Peanut Butter", 1, 2); 
    INSERT INTO groceries VALUES (3, "Dark Choclate", 2, 2); 
    INSERT INTO groceries VALUES (4, "Ice Cream", 1, 12); 
    INSERT INTO groceries VALUES (5, "Cherries", 6, 2); 
    INSERT INTO groceries VALUES (6, "Chocolate Syrup", 1, 4); 
    
    SELECT SUM(quantity) FROM groceries; 
    SELECT SUM(quantity) FROM groceries GROUP BY aisle; 
    SELECT aisle, SUM(quantity) FROM groceries GROUP BY aisle; **first grouped by aisle, summed quantity and selected first aisle value 

## More complex queries with AND/OR
    CREATE TABLE exercise_logs (id INTEGER PRIMARY KEY AUTOINCREMENT, type TEXT, minutes INTEGER, calories INTEGER, heart_rate INTEGER); 
      **id column is primary key and set to autoincrement, the database will automatically fill it in for us, usually a number bigger than the one so far
    
    INSERT INTO exercise_logs(type, minutes, calories, heart_rate) VALUES ("biking, 30, 100, 110); 
    
    SELECT * FROM exercise_logs WHERE calories > 50 ORDER BY calories; 
    SELECT * FROM exercise_logs WHERE calories > 50 AND minutes < 30; 
    SELECT * FROM exercise_logs WHERE calories > 50 OR heart_rate > 100; 
    
    ** AND has precendence over the OR operator, can use them as much as needed in wach query
    
 ## Querying IN subqueries
    SELECT * FROM exercise_logs WHERE type ="biking" OR type ="hiking"; 
    SELECT * FROM exercise_logs WHERE type IN ("biking, "hiking", "tree climbing"); 
    SELECT * FROM exercise_logs WHERE type IN (SELECT type FROM drs_favorites); **will always pull based on whats in the drs_favorite 
    
 ## LIKE operator
    SELECT * FROM exercise_logs WHERE type IN (SELECT type FROM drs_favorites WHERE reason LIKE "cardiovascular%");
   
## Challenge with IN subqueries
    CREATE TABLE artists (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT,
    country TEXT,
    genre TEXT);

    INSERT INTO artists (name, country, genre)
        VALUES ("Taylor Swift", "US", "Pop");
    INSERT INTO artists (name, country, genre)
        VALUES ("Led Zeppelin", "US", "Hard rock");
    INSERT INTO artists (name, country, genre)
        VALUES ("ABBA", "Sweden", "Disco");
    INSERT INTO artists (name, country, genre)
        VALUES ("Queen", "UK", "Rock");
    INSERT INTO artists (name, country, genre)
        VALUES ("Celine Dion", "Canada", "Pop");
    INSERT INTO artists (name, country, genre)
        VALUES ("Meatloaf", "US", "Hard rock");
    INSERT INTO artists (name, country, genre)
        VALUES ("Garth Brooks", "US", "Country");
    INSERT INTO artists (name, country, genre)
        VALUES ("Shania Twain", "Canada", "Country");
    INSERT INTO artists (name, country, genre)
        VALUES ("Rihanna", "US", "Pop");
    INSERT INTO artists (name, country, genre)
        VALUES ("Guns N' Roses", "US", "Hard rock");
    INSERT INTO artists (name, country, genre)
        VALUES ("Gloria Estefan", "US", "Pop");
    INSERT INTO artists (name, country, genre)
        VALUES ("Bob Marley", "Jamaica", "Reggae");

    CREATE TABLE songs (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        artist TEXT,
        title TEXT);

    INSERT INTO songs (artist, title)
        VALUES ("Taylor Swift", "Shake it off");
    INSERT INTO songs (artist, title)
        VALUES ("Rihanna", "Stay");
    INSERT INTO songs (artist, title)
        VALUES ("Celine Dion", "My heart will go on");
    INSERT INTO songs (artist, title)
        VALUES ("Celine Dion", "A new day has come");
    INSERT INTO songs (artist, title)
        VALUES ("Shania Twain", "Party for two");
    INSERT INTO songs (artist, title)
        VALUES ("Gloria Estefan", "Conga");
    INSERT INTO songs (artist, title)
        VALUES ("Led Zeppelin", "Stairway to heaven");
    INSERT INTO songs (artist, title)
        VALUES ("ABBA", "Mamma mia");
    INSERT INTO songs (artist, title)
        VALUES ("Queen", "Bicycle Race");
    INSERT INTO songs (artist, title)
        VALUES ("Queen", "Bohemian Rhapsody");
    INSERT INTO songs (artist, title)
        VALUES ("Guns N' Roses", "Don't cry");


    SELECT title FROM songs WHERE artist="Queen";
    SELECT name FROM artists WHERE genre="Pop";
    SELECT title FROM songs WHERE artist IN (SELECT name FROM artists WHERE genre="Pop");

## Grouped Results with HAVING
    SELECT * FROM exercise_logs;
    SELECT type, SUM(calories) FROM exercise_logs GROUP BY type;
        SELECT type, SUM(calories) AS total_calories FROM exercise_logs GROUP BY type;
    SELECT type, SUM(calories) AS total_calories FROM exercise_logs GROUP BY type
                                                  HAVING total_calories > 150; **grabs logs >150 across all rows
    SELECT type, AVG(calories) AS avg_calories FROM exercise_logs GROUP BY type
                                                  HAVING total_calories > 70;
    
    SELECT type FROM exercise_logs GROUP BY type
    HAVING COUNT(*) >=2; **grabs logs that have more than 2 records
    
    ** It is easy to confuse HAVING and WHERE
    
## Challenge with GROUP BY and HAVING
    CREATE TABLE books (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    author TEXT,
    title TEXT,
    words INTEGER);
    
    INSERT INTO books (author, title, words)
        VALUES ("J.K. Rowling", "Harry Potter and the Philosopher's Stone", 79944);
    INSERT INTO books (author, title, words)
        VALUES ("J.K. Rowling", "Harry Potter and the Chamber of Secrets", 85141);
    INSERT INTO books (author, title, words)
        VALUES ("J.K. Rowling", "Harry Potter and the Prisoner of Azkaban", 107253);
    INSERT INTO books (author, title, words)
        VALUES ("J.K. Rowling", "Harry Potter and the Goblet of Fire", 190637);
    INSERT INTO books (author, title, words)
        VALUES ("J.K. Rowling", "Harry Potter and the Order of the Phoenix", 257045);
    INSERT INTO books (author, title, words)
        VALUES ("J.K. Rowling", "Harry Potter and the Half-Blood Prince", 168923);
    INSERT INTO books (author, title, words)
        VALUES ("J.K. Rowling", "Harry Potter and the Deathly Hallows", 197651);

    INSERT INTO books (author, title, words)
        VALUES ("Stephenie Meyer", "Twilight", 118501);
    INSERT INTO books (author, title, words)
        VALUES ("Stephenie Meyer", "New Moon", 132807);
    INSERT INTO books (author, title, words)
        VALUES ("Stephenie Meyer", "Eclipse", 147930);
    INSERT INTO books (author, title, words)
        VALUES ("Stephenie Meyer", "Breaking Dawn", 192196);

    INSERT INTO books (author, title, words)
        VALUES ("J.R.R. Tolkien", "The Hobbit", 95022);
    INSERT INTO books (author, title, words)
        VALUES ("J.R.R. Tolkien", "Fellowship of the Ring", 177227);
    INSERT INTO books (author, title, words)
        VALUES ("J.R.R. Tolkien", "Two Towers", 143436);
    INSERT INTO books (author, title, words)
        VALUES ("J.R.R. Tolkien", "Return of the King", 134462);
        
    SELECT author, SUM(words) AS total_words FROM books GROUP BY author HAVING total_words > 1000000;
    SELECT author, AVG(words) AS avg_words FROM books GROUP BY author HAVING avg_words > 150000;

## Caluclating Results with CASE **CASE is tricky (similar to a If or Switch in other languages)
   SELECT * FROM exercise_logs;
   SELECT COUNT(*) FROM exercise_logs WHERE heart_rate > 220 - 30; 
   SELECT COUNT(*) FROM exercise_logs WHERE heart_rate > ROUND(0.50 * (22-30)) AND heart_rate <= ROUND(0.90 * (220-30)); 
   
   SELECT COUNT(*),
          CASE
              WHEN heart_rate > 220-30 THEN "above max" 
              WHEN heart_rate > ROUND(0.90 * (220-30)) THEN "above target"
              WHEN heart_rate > ROUND(0.50 * (220-30)) THEN "within target"
              ELSE "below target"
              END as "hr_zone"
              FROM exercise_logs
              GROUP BY hr_zone;
    
 ## Challenge: Useing CASE
      CREATE TABLE student_grades (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          name TEXT,
          number_grade INTEGER,
          fraction_completed REAL);

      INSERT INTO student_grades (name, number_grade, fraction_completed)
          VALUES ("Winston", 90, 0.805);
      INSERT INTO student_grades (name, number_grade, fraction_completed)
          VALUES ("Winnefer", 95, 0.901);
      INSERT INTO student_grades (name, number_grade, fraction_completed)
          VALUES ("Winsteen", 85, 0.906);
      INSERT INTO student_grades (name, number_grade, fraction_completed)
          VALUES ("Wincifer", 66, 0.7054);
      INSERT INTO student_grades (name, number_grade, fraction_completed)
          VALUES ("Winster", 76, 0.5013);
      INSERT INTO student_grades (name, number_grade, fraction_completed)
          VALUES ("Winstonia", 82, 0.9045);

      SELECT name, number_grade, (ROUND(fraction_completed*100)) AS percent_completed FROM student_grades; 

      SELECT COUNT(*),
              CASE
                  WHEN number_grade > 90 THEN "A" 
                  WHEN number_grade > 80 THEN "B"
                  WHEN number_grade > 70 THEN "C"
                  ELSE "F"
                  END as "letter_grade"
                  FROM student_grades
                  GROUP BY letter_grade;

    
    
    
    
  
    
